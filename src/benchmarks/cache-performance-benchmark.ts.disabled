/*/* TEMPORARILY DISABLED - Requires API updates
#!/usr/bin/env tsx

import { performance } from 'perf_hooks';
import { databaseManager } from '../db/database.ts';
import { EncryptionService } from '../services/EncryptionService.ts';
import { AuditLogger } from '../services/AuditLogger.ts';
import { getCacheService, resetCacheService } from '../services/CacheService.ts';
import { getCacheMetrics } from '../utils/cache-metrics.ts';
import type Database from 'better-sqlite3';

// Import base repositories
import { CaseRepository } from '../repositories/CaseRepository.ts';
import { EvidenceRepository } from '../repositories/EvidenceRepository.ts';
import { SessionRepository } from '../repositories/SessionRepository.ts';
import { UserProfileRepository } from '../repositories/UserProfileRepository.ts';

// Import cached repositories
import { CachedCaseRepository } from '../repositories/CachedCaseRepository.ts';
import { CachedEvidenceRepository } from '../repositories/CachedEvidenceRepository.ts';
import { CachedSessionRepository } from '../repositories/CachedSessionRepository.ts';
// import { CachedUserProfileRepository } from '../repositories/CachedUserProfileRepository.ts'; // DELETED FILE

import type { CreateCaseInput } from '../domains/cases/entities/Case.ts';
import type { CreateEvidenceInput } from '../domains/evidence/entities/Evidence.ts';
import type { CreateSessionInput } from '../domains/auth/entities/Session.ts';

/**
 * Performance benchmark for LRU cache implementation
 * Compares direct database access vs cached access
 */

interface BenchmarkResult {
  operation: string;
  directMs: number;
  cachedFirstMs: number;
  cachedSecondMs: number;
  speedup: number;
  hitRate: number;
}

class CachePerformanceBenchmark {
  private encryptionService: EncryptionService;
  private auditLogger: AuditLogger;
  private _results: BenchmarkResult[] = [];

  constructor(db: Database.Database) {
    // Initialize services
    const encryptionKey = Buffer.from('test-key-for-benchmarking-only!!').toString('base64');
    this.encryptionService = new EncryptionService(encryptionKey);
    this.auditLogger = new AuditLogger(db);
  }

  /**
   * Run a single benchmark iteration
   */
  private async runBenchmark(
    name: string,
    directFn: () => Promise<any>,
    cachedFn: () => Promise<any>
  ): Promise<BenchmarkResult> {
    // Clear cache before each benchmark
    const cacheService = getCacheService();
    cacheService.clear();
    cacheService.resetStats();

    // Measure direct database access
    const startDirect = performance.now();
    await directFn();
    const endDirect = performance.now();

    // Measure cached access (first call - should miss)
    const startCachedFirst = performance.now();
    await cachedFn();
    const endCachedFirst = performance.now();

    // Measure cached access (second call - should hit)
    const startCachedSecond = performance.now();
    await cachedFn();
    const endCachedSecond = performance.now();

    // Get cache metrics
    const metrics = getCacheMetrics();
    
    // Calculate results
    const directMs = endDirect - startDirect;
    const cachedFirstMs = endCachedFirst - startCachedFirst;
    const cachedSecondMs = endCachedSecond - startCachedSecond;
    const speedup = directMs / cachedSecondMs;
    
    // Log results instead of using console.log
    const result: BenchmarkResult = {
      operation: name,
      directMs,
      cachedFirstMs,
      cachedSecondMs,
      speedup,
      hitRate: metrics.hitRate
    };

    return result;
  }

  /**
   * Run all benchmarks
   */
  public async runAllBenchmarks(): Promise<BenchmarkResult[]> {
    const db = await databaseManager.getDatabase();
    const results: BenchmarkResult[] = [];
    
    // Initialize repositories
    const caseRepo = new CaseRepository(db);
    const evidenceRepo = new EvidenceRepository(db);
    const sessionRepo = new SessionRepository(db);
    const userProfileRepo = new UserProfileRepository(db);
    
    const cachedCaseRepo = new CachedCaseRepository(db);
    const cachedEvidenceRepo = new CachedEvidenceRepository(db);
    const cachedSessionRepo = new CachedSessionRepository(db);
    const cachedUserProfileRepo = new CachedUserProfileRepository(db);
    
    // Test case operations
    const testCase: CreateCaseInput = {
      title: 'Test Case',
      description: 'Test Description',
      status: 'open',
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    // Test evidence operations
    const testEvidence: CreateEvidenceInput = {
      caseId: 1,
      description: 'Test Evidence',
      type: 'document',
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    // Test session operations
    const testSession: CreateSessionInput = {
      userId: 1,
      token: 'test-token',
      expiresAt: new Date(Date.now() + 3600000),
      createdAt: new Date()
    };
    
    // Run benchmarks
    try {
      // Case operations
      const caseResult = await this.runBenchmark(
        'Case Operations',
        () => caseRepo.create(testCase),
        () => cachedCaseRepo.create(testCase)
      );
      results.push(caseResult);
      
      // Evidence operations
      const evidenceResult = await this.runBenchmark(
        'Evidence Operations',
        () => evidenceRepo.create(testEvidence),
        () => cachedEvidenceRepo.create(testEvidence)
      );
      results.push(evidenceResult);
      
      // Session operations
      const sessionResult = await this.runBenchmark(
        'Session Operations',
        () => sessionRepo.create(testSession),
        () => cachedSessionRepo.create(testSession)
      );
      results.push(sessionResult);
      
      // User Profile operations
      const userProfileResult = await this.runBenchmark(
        'User Profile Operations',
        () => userProfileRepo.findById(1),
        () => cachedUserProfileRepo.findById(1)
      );
      results.push(userProfileResult);
      
      // Print results using allowed console methods
      results.forEach(result => {
        console.warn(`Operation: ${result.operation}`);
        console.warn(`  Direct: ${result.directMs.toFixed(2)}ms`);
        console.warn(`  Cached First: ${result.cachedFirstMs.toFixed(2)}ms`);
        console.warn(`  Cached Second: ${result.cachedSecondMs.toFixed(2)}ms`);
        console.warn(`  Speedup: ${result.speedup.toFixed(2)}x`);
        console.warn(`  Hit Rate: ${(result.hitRate * 100).toFixed(2)}%`);
        console.warn('');
      });
      
      return results;
    } catch (error) {
      console.error('Benchmark failed:', error);
      throw error;
    }
  }
}

// Run the benchmark
async function runBenchmark() {
  try {
    const db = await databaseManager.getDatabase();
    const benchmark = new CachePerformanceBenchmark(db);
    const results = await benchmark.runAllBenchmarks();
    
    console.warn(`Benchmark completed. Processed ${results.length} operations.`);
  } catch (error) {
    console.error('Failed to run benchmark:', error);
  }
}

if (require.main === module) {
  runBenchmark();
}

export { CachePerformanceBenchmark };*/
